\documentclass[letter]{article}
\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage[table]{xcolor}
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{algpseudocode} % Required for pseudocode listing
\usepackage{courier} % Required for the courier font
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{tikz}
\usetikzlibrary{arrows, shapes, positioning, calc}
\usepackage{caption}
\usepackage{wasysym}
\usepackage{multirow}
\usepackage{float}
\usepackage{tcolorbox}
\usepackage{csquotes}
\usepackage{fancybox}
\usepackage{enumitem}
\usepackage[letterspace=150]{microtype}
\usepackage{cancel}
\usepackage{bm}
\usepackage{makeidx}
\usepackage{url}

\usepackage{sourcecodepro}

\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\sourcecodepro\footnotesize ,        % the size of the fonts that are used for the code
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={(*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C,                 % the language of the code
  morekeywords={repeat,integer,function,end,*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
%\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
%\pagestyle{fancy}
%\renewcommand\headrulewidth{0.4pt} % Size of the header rule
%\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\renewcommand{\familydefault}{\sfdefault}

\newcommand{\m}[1]{{\bf{#1}}}
\newcommand{\tr}{^{\sf T}}

\title{Mongoose User Guide}
\author{Scott Kolodziej}
%\date{}

\makeindex

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Overview}
% What is the problem we're solving? What does this package do?
Mongoose is a graph partitioning library that can quickly compute edge cuts in arbitrary graphs. Given a graph with a vertex set $V$ and edge set $E$, an edge cut is a partitioning of the graph into two subgraphs that are balanced (contain the same number of vertices) and the connectivity between the subgraphs is minimized (few edges are in the cut).
\\

Finding high quality edge cuts quickly is an important part of circuit simulation, parallel and distributed computing, and sparse matrix algorithms.

\subsection{Coarsening and Refinement Framework}

Mongoose uses a coarsening and refinement framework (sometimes referred to as a multilevel framework \cite{HendricksonLeland1995, KarypisKumar1995}). Rather than attempt to compute an edge cut on the input graph directly, Mongoose first coarsens the graph by computing a vertex matching and contracting the graph to form a smaller, but structurally similar, graph.

\begin{figure}[!ht] 
\begin{center} 
    \includegraphics[scale=0.18]{Figures/MultilevelOverview.eps} 
    \caption{Coarsening and Refinement} 
\end{center} 
\end{figure} 

Mongoose uses a variety of methods to coarsen the input graph, including random matching and heavy-edge matching. Additionally, Mongoose offers stall-reducing vertex matching strategies called Brotherly (or two-hop) matching and Community matching. Brotherly matching allows vertices who share a neighbor to be matched, even if they have no edge directly connecting them, and community matching allows two vertices whose neighbors are matched together to be matched together. These methods are advantageous in efficiently coarsening certain classes of graphs, notably social networking graphs, where the vertex degree can vary greatly.

\begin{center}
\begin{minipage}[c]{0.47\linewidth}
    \includegraphics[scale=0.26]{Figures/BrotherlyMatching.eps} 
    \captionof{figure}{Brotherly Matching} 
\end{minipage}
\hspace{22pt}
\begin{minipage}[c]{0.47\linewidth}
    \includegraphics[scale=0.26]{Figures/CommunityMatching.eps} 
    \captionof{figure}{Community Matching} 
\end{minipage}
\end{center}

Another matching strategy used in Mongoose is known as Adoption matching. If an unmatched vertex has no unmatched neighbors, it can be grouped into a 3-way matching with a neighboring matched vertex. These strategies allow the graph to be coarsened quickly even when the graph is highly irregular, which in turn decreases memory requirements and overall computational time.

\subsection{Quadratic Programming and Optimization}

Mongoose is known as a hybrid graph partitioner, as it uses multiple methods in tandem to find higher quality cuts efficiently. The first such method Mongoose employs is quadratic programming (QP). The edge cut problem was formatted as a continuous quadratic programming problem by Hager and Krylyuk \cite{HagerKrylyuk1999}. This formulation is solved (rather, improved) using a gradient projection algorithm and a modified version of NAPHEAP, a quadratic knapsack solver \cite{DavisHagerHungerford2016}.
\\

The quadratic program used is shown below. Hager and Krylyuk have proven that the global optimum to this quadratic program yields the solution to the graph partitioning problem (but note that both are NP-hard problems to solve).
%
\begin{eqnarray}
&\displaystyle\min_{\m{x}\in\mathbb{R}^n}\quad  (\m{1} - \m{x})\tr (\m{A} + \m{I})\m{x}
& \quad \mbox{subject to}  \quad
\m{0} \le \m{x} \le \m{1}, \quad \ell \le \m{1}\tr \m{x} \le u, \nonumber
\end{eqnarray}

$\ell$ and $u$ are lower and upper bounds on the desired size of one partition, and $\m{A}$ is the adjacency matrix of the graph.

\subsection{Fiduccia-Mattheyses Algorithm}

In addition to the quadratic programming approach for refining an edge cut, a standard implementation of the Fiduccia-Mattheyses algorithm \cite{FiducciaMattheyses1982} is also provided. This involves swapping vertices from one part to the other in an effort to improve the edge cut quality. Some vertices are swapped even if no immediate improvement is found in an attempt to escape a locally optimal solution. However, if no improvement is found after a number of swaps, the change is reverted.\\
\\
The Fiduccia-Mattheyses (FM) implementation in Mongoose utilizes heaps for high efficiency. 

\section{Availability}

\subsection{Getting the Code}
Mongoose is available on GitHub at \url{https://github.com/ScottKolo/Mongoose}. The code can be downloaded using \texttt{git} using the following command:
\[\text{\texttt{git clone https://github.com/ScottKolo/Mongoose}}\]
Alternatively, Mongoose can be downloaded as a zip archive from the following URL:
\[\text{\url{https://github.com/ScottKolo/Mongoose/archive/edgesep.zip}}\] 

\subsection{Prerequisites}
Mongoose requires CMake 2.8 and any ISO/IEC 14882:1998 compliant C++ compiler. Mongoose has been tested to work with GNU GCC 4.4+ and LLVM Clang 3.5+ on Linux, and Apple Xcode 6.4+ on macOS.

\subsection{Compilation}
Once downloaded, Mongoose can be compiled using the following commands:\\

\begin{lstlisting}[language=bash,numbers=none,xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
cd Mongoose
mkdir _build # Create a build directory
cd _build 
cmake ..     # Use CMake to create the Makefiles
make         # Build Mongoose
\end{lstlisting}

After compilation, the Mongoose demo can be run using \texttt{./bin/Demo}:\\

\begin{lstlisting}[numbers=none,xleftmargin=.2\textwidth, xrightmargin=.2\textwidth,keywordstyle=\color{black}]
./bin/Demo
**************************************************
Computing an edge cut for bcspwr01.mtx...
Partitioning Complete!
Cut Cost:       3
Cut Imbalance:  1.3%
Normalized Cut: 0.13
Trial Time:     1ms
**************************************************

...

**************************************************
Computing an edge cut for troll.mtx...
Partitioning Complete!
Cut Cost:       4.1e+04
Cut Imbalance:  0.00023%
Normalized Cut: 0.014
Trial Time:     3.28e+03ms
**************************************************
Total Demo Time:  3.4s

**************************************************
***************** Demo Complete! *****************
**************************************************
\end{lstlisting}

To run the complete test suite, the command \texttt{make test} can be used. Note that Python 2.7+ must be installed.

\section{Using Mongoose as an Executable}

In addition to the Demo executable, the \texttt{mongoose} executable is built at \texttt{./bin/mongoose}. This executable can be used to partition a graph given a Matrix Market file:

\[\text{\texttt{mongoose <MM-input-file.mtx> [output-file]}}\]

The \texttt{mongoose} executable generates a text file with two blocks: a JSON-formatted information block with timing and cut quality metrics, and the partitioning information itself. The partitioning information is listed with one vertex per line, with the vertex number followed by the part (0 for part A, 1 for part B).\\

For example, the following can be used to partition \texttt{troll.mtx}:

\begin{lstlisting}[numbers=none,xleftmargin=.2\textwidth, xrightmargin=.2\textwidth,keywordstyle=\color{black}]
./bin/mongoose ../Matrix/troll.mtx troll_out.mtx
Total Edge Separator Time: 1.00848s
 Matching:   0.08622s
 Coarsening: 0.2118s
 Refinement: 0.05528s
 FM:         0.003129s
 QP:         0.5684s
 IO:         2.522s
Cut Properties:
 Cut Size:       50837
 Cut Cost:       5.084e+04
 Normalized Cut: 0.01727
 Imbalance:      2.342e-06

cat jagmesh7_out.txt 
{
  "InputFile": "../Matrix/troll.mtx",
  "Timing": {
    "Total": 1.00848,
    "Matching": 0.086223,
    "Coarsening": 0.211779,
    "Refinement": 0.055275,
    "FM": 0.003129,
    "QP": 0.568422,
    "IO": 2.52204
  },
  "CutSize": 50837,
  "CutCost": 50837,
  "NormCut": 0.0172744,
  "Imbalance": 2.34244e-06
}

0 0
1 0
2 0

...

204829 1
204830 1
204831 0
204832 0

...

213450 0
213451 0
213452 0
\end{lstlisting}

The output file name is optional. If omitted, the default is \texttt{mongoose\_out.txt}.

\subsection{License}

Mongoose is licensed under the GNU Public License version 3 (GPLv3). Full text of the license can be found int \texttt{Mongoose/LICENSE}. For a commercial license, please contact Dr. Timothy A. Davis at davis@tamu.edu.

\section{Using Mongoose in C++}

\subsection{Sample C++ Program}
% Without weights, with edge weights, with vertex weights

\begin{lstlisting}
#include "Mongoose.hpp"
#include <iostream>
#include <iomanip>

using namespace Mongoose;
using namespace std;

int main(int argn, const char **argv)
{
    Options *options = Options::Create();
    if (!options) return EXIT_FAILURE; // Return an error if we failed.

    options->matchingStrategy = HEMDavisPA;
    options->guessCutType = GuessQP;

    Graph *graph = readGraph(argv[1]);
    if (!graph)
    {
    	options->~Options();
    	return EXIT_FAILURE;
    }
	
    // Call Mongoose to compute an edge separator
    ComputeEdgeSeparator (graph, options);

    cout << "Partitioning Complete!" << endl;
    cout << "Cut Cost:      " << setprecision(2) << graph->cutCost << endl;
    cout << "Cut Imbalance: " << setprecision(2) << fabs(100*graph->imbalance) << "%" << endl;
	
	options->~Options();
    graph->~Graph();

    /* Return success */
    return EXIT_SUCCESS;
}
\end{lstlisting}

\subsection{C++ API}

The following functions are available in the C++ API. After Mongoose is compiled, a static library version of Mongoose is built at \texttt{Mongoose/\_build/lib/libmongoose.a}. Include the \texttt{Mongoose.hpp} header file located in \texttt{Mongoose/Include} and link with the static library to enable the following API functions.

\begin{itemize}
\item \textbf{\texttt{Graph *readGraph(const std::string \&filename);}} \vspace{-6pt}
\item \textbf{\texttt{Graph *readGraph(const char *filename);}}

\texttt{Mongoose::readGraph} will attempt to read a Matrix Market file with the given filename and convert it to a Mongoose Graph instance. The matrix contained in the file must be sparse, real, and square. If the matrix is not symmetric, it will be made symmetric by computing $\frac{1}{2}(A+A^T)$. If a diagonal is present, it will be removed.

\texttt{Mongoose::readGraph(const std::string \&filename)} accepts a C++-style std::string, while \texttt{Mongoose::readGraph(const char *filename)} accepts a C-style null-terminated string.
\vspace{6pt}
\item \textbf{\texttt{int ComputeEdgeSeparator(Graph *);}} \vspace{-6pt}
\item \textbf{\texttt{int ComputeEdgeSeparator(Graph *, const Options *);}}

\texttt{Mongoose::ComputeEdgeSeparator} will attempt to compute an edge cut of the provided \texttt{Mongoose::Graph} object. An \texttt{Options} struct can also be supplied to modify how the edge cut is computed -- otherwise, the default options are used (see Section \ref{sec:options}).
\vspace{6pt}
\item \textbf{\texttt{static Options *Create();}}

\texttt{Mongoose::Options::Create} will return an \texttt{Options} struct with default state (see Section \ref{sec:options} for details about option fields and defaults). To run Mongoose with specific options, call \texttt{Options::Create} and modify the struct as needed.
\vspace{6pt}
\item \textbf{\texttt{static Graph *Create(Int \_n, Int \_nz);}}
\item \textbf{\texttt{static Graph *Create(Graph *\_parent);}}

\vspace{6pt}
\item \textbf{\texttt{$\sim$Options();}}
\item \textbf{\texttt{$\sim$Graph();}}

\end{itemize}

\subsection{A Note on Memory Management}

Mongoose uses two primary data structures to pass information: the \texttt{Graph} class and the \texttt{Options} struct. Both are dynamically allocated and must be destructed.

\begin{itemize}
\item For each \texttt{Graph::Create}, there should be a matching \texttt{Graph::$\sim$Graph()}.
\item for each \texttt{Options::Create}, there should be a matching \texttt{Options::$\sim$Options()};
\end{itemize}

\section{Using Mongoose in MATLAB}

\subsection{Sample MATLAB Program}
% Without weights, with edge weights, with vertex weights

Below is a sample MATLAB program using the Mongoose MATLAB API. First, it loads in a matrix, sanitizes it, and then partitions it using edge and vertex weights, then only edge weights, and the no weights.

\begin{lstlisting}[language=MATLAB]
% A simple demo to demonstrate Mongoose. Reads in a matrix, sanitizes it,
% and partitions it several different ways.
function mongoose_demo

% Obtain the adjacency matrix
matfile_data = matfile('494_bus.mat');
Prob = matfile_data.Problem;
A = Prob.A;
[m ~] = size(A);

% Sanitize the adjacency matrix: remove diagonal elements, make edge weights 
% positive, and make sure it is symmetric. If the matrix is not symmetric 
% or square, a symmetric matrix (A+A')/2 is built.
A = sanitize(A);

% Create a node weight vector and create a heavy node
V = ones(1,m);
V(10) = 300;

% Create a set of default options and modify the target balance
O = defaultoptions();
O.targetSplit = 0.3;

% Run Mongoose to partition the graph with edge and node weights.
partNode = edgecut(A, O, V);

fprintf('\n\nPartitioning graph with edge and node weights\n\n');
fprintf('=== Cut Info ===\n');
fprintf('Cut Size:   %d\n', full(sum(partNode .* sum(sign(A)))));
fprintf('Cut Weight: %d\n\n', full(sum(partNode .* sum(A))));
fprintf('=== Balance Info ===\n');
fprintf('Target Split:     0.3\n');
fprintf('Actual Split:     %1.4f\n', sum(partNode .* V) / sum(V));
fprintf('Unweighted Split: %1.4f\n', sum(partNode) / m);

% Run Mongoose to partition the graph with no vertex weights.
partEdge = edgecut(A, O);

fprintf('\n\nPartitioning graph with only edge weights\n\n');
fprintf('=== Cut Info ===\n');
fprintf('Cut Size:   %d\n', full(sum(partEdge .* sum(sign(A)))));
fprintf('Cut Weight: %d\n\n', full(sum(partEdge .* sum(A))));
fprintf('=== Balance Info ===\n');
fprintf('Target Split: 0.5\n');
fprintf('Actual Split: %1.4f\n', sum(partEdge) / m);

% Remove edge weights
A = sanitize(A, 1);

% Run Mongoose to partition the graph with no edge weights.
% Note that only the graph is passed as an argument, so default
% options are assumed.
partPattern = edgecut(A);

fprintf('\n\nPartitioning graph with only edge weights\n\n');
fprintf('=== Cut Info ===\n');
fprintf('Cut Size:   %d\n', full(sum(partPattern .* sum(sign(A)))));
fprintf('Cut Weight: %d\n\n', full(sum(partPattern .* sum(A))));
fprintf('=== Balance Info ===\n');
fprintf('Target Split: 0.5\n');
fprintf('Actual Split: %1.4f\n', sum(partPattern) / m);

figure('Position', [100, 100, 1000, 400]);

% Plot the original matrix before permutation
subplot(1, 2, 1);
spy(A)
title('Before Partitioning')

% Plot the matrix after the permutation
subplot(1, 2, 2);
perm = [find(partEdge) find(1-partEdge)];
A_perm = A(perm, perm); % Permute the matrix
spy(A_perm)
title('After Partitioning')

% Set overall title
suptitle('HB/494\_bus')

end
\end{lstlisting}

\subsection{MATLAB API}

\begin{itemize}
\item \textbf{\texttt{function [G\_coarse, A\_coarse, map] = coarsen (G, \textit{O}, \textit{A})}}\\
\texttt{coarsen} is used to coarsen an adjacency matrix (\texttt{G}) one level (one round of matching). An optional options struct (\texttt{O}) can be specified, as well as node weights (\texttt{A}).
\\
\item \textbf{\texttt{function options = defaultoptions()}}\\
\texttt{defaultoptions()} returns an options struct with defaults set. If modifications to the default options are needed, call \texttt{defaultoptions()} and modify the struct as needed. See section \ref{sec:options} for details on available option fields.
\\
\item \textbf{\texttt{function partition = edgecut (G, \textit{O}, \textit{A})}}\\
\texttt{edgecut} computes an edge cut of the graph \texttt{G} with options \texttt{O} and vertex weights \texttt{A}, such that \texttt{A(i)} = $\text{weight}(v_i)$. The returned array, \texttt{partition}, is a $1 \times n$ binary array such that
\[
\texttt{partition(i)} = 
  \begin{cases} 
   0 & \text{if } v_i \in \text{part A} \\
   1 & \text{if } v_i \in \text{part B}
  \end{cases}
\]
\item \textbf{\texttt{function [G\_coarse, A\_coarse, map] = safe\_coarsen (G, \textit{O}, \textit{A})}}\\
\texttt{safe\_coarsen} attempts to coarsen a graph \texttt{G} with options \texttt{O} and vertex weights \texttt{A}. Prior to coarsening, \texttt{safe\_coarsen} first calls \texttt{sanitize(G)} to ensure that the graph is able to be coarsened.
\\
\item \textbf{\texttt{function partition = safe\_edgecut(G, \textit{O}, \textit{A})}}\\
\texttt{safe\_edgecut} attempts to compute and edge cut for a graph \texttt{G} with options \texttt{O} and vertex weights \texttt{A}. Note that both \texttt{O} and \texttt{A} are optional arguments. \texttt{safe\_edgecut} first calls \texttt{sanitize(G)} to ensure that the graph is formatted correctly.
\\ 
\item \textbf{\texttt{function A\_safe = sanitize (A, \textit{make\_binary})}}\\
\texttt{sanitize} attempts to take an adjacency matrix \texttt{A} and convert it to one that Mongoose can read and convert to an undirected graph. Note that \texttt{make\_binary} is optional, with the default being \texttt{false}. \texttt{sanitize} does the following as needed:

\begin{itemize}
\item If the matrix is unsymmetric, it forms $\frac{1}{2}(A^T + A)$.
\item The diagonal is removed (set to zero).
\item Edge weights are forced to be positive ($w = |w|$) if \texttt{make\_binary = false}.
\item Edge weights are forced to be binary ($w = \text{sign}(w)$) if \texttt{make\_binary = true}.
\end{itemize}

\end{itemize}

\section{Options}
\label{sec:options}

When calling Mongoose, an optional Options struct can be provided to specify how Mongoose should behave.

\subsection{Coarsening Options}

\begin{tabular}{|l|l|} \hline
Name & \texttt{coarsenLimit} \\ \hline
Type & \texttt{Int} \\ \hline
Default & \texttt{50} \\ \hline
\end{tabular}\\

Prior to computing a cut, the input graph is repeatedly coarsened until a sufficiently small number of vertices exist in the graph. This limit is specified by \texttt{coarsenLimit}. Larger values will result in less time being spent on the coarsening process, but may yield poor initial cuts or may require more time in computing such an initial cut. Smaller values may result in more time spent coarsening, as well as a resulting coarsened graph which is a poor structural representation of the input graph.

\vskip 1\baselineskip
\begin{tabular}{|l|l|} \hline
Name & \texttt{matchingStrategy} \\ \hline
Type & \texttt{MatchingStrategy} (enum) \\ \hline
Default & \texttt{HEMDavisPA} \\ \hline
\end{tabular}\\

During coarsening, a matching of vertices is computed using one of several strategies determined by the \texttt{matchingStrategy} option field. The possible values for this field are described below:

\begin{itemize}
\item \texttt{Random}, random matching. Randomly matches unmatched vertices with each other until no more than one unmatched vertex exists.
\item \texttt{HEM}, heavy edge matching. Matches a given vertex with an unmatched neighbor with the largest weighted edge between them.
\item \texttt{HEMPA}, heavy edge matching with passive-aggressive matching. A pass of heavy edge matching is followed by a passive-aggressive matching where vertices that have been left unmatched by heavy edge matching are paired with vertices that share a neighbor, but may not be directly connected.
\item \texttt{HEMDavisPA}, heavy edge matching with passive-aggressive matching subject to a brotherly threshold. Same as \texttt{HEMPA}, but the passive-aggressive step is only attempted on unmatched vertices whose degree is above a threshold, described by $\texttt{Options::davisBrotherlyThreshold}*\text{(average degree of graph)}$. \texttt{davisBrotherlyThreshold} is set to $2.0$ by default, meaning only unmatched vertices with degree greater than or equal to two times the average degree of the graph are considered for passive-aggressive matching.
\end{itemize}

\vskip 1\baselineskip
\begin{tabular}{|l|l|} \hline
Name & \texttt{doCommunityMatching} \\ \hline
Type & \texttt{bool} \\ \hline
Default & \texttt{false} \\ \hline
\end{tabular}\\

Community matching is a matching option to aggressively match vertices whose neighbors have already been matched. This can help in cases where coarsening easily stalls (e.g. social networking graphs), but incurs a slight performance overhead during coarsening.

\vskip 1\baselineskip
\begin{tabular}{|l|l|} \hline
Name & \texttt{davisBrotherlyThreshold} \\ \hline
Type & \texttt{double} \\ \hline
Default & \texttt{2.0} \\ \hline
\end{tabular}\\

When using the \texttt{HEMDavisPA} matching strategy, only vertices satisfying the following inequality are considered for passive-aggressive matching:

\[
\text{degree}(v) \geq \lfloor(\texttt{davisBrotherlyThreshold}) \cdot \left(\frac{nz}{n}\right)\rfloor
\]

Note that $\frac{nz}{n}$ is the average degree of the vertices in the graph.

\subsection{Initial Guess/Partitioning Options}

\begin{tabular}{|l|l|} \hline
Name & \texttt{guessCutType} \\ \hline
Type & \texttt{GuessCutType} (enum) \\ \hline
Default & \texttt{GuessQP} \\ \hline
\end{tabular}\\

After coarsening, an initial partitioning is computed. This initial guess can be computed several ways:

\begin{itemize}
\item \texttt{GuessQP}. This method uses the quadratic programming solver to compute an initial partitioning.
\item \texttt{GuessRandom}. This method randomly assigns vertices to a part.
\item \texttt{GuessNaturalOrder}. This method assigns the first $\lfloor n/2 \rfloor$ vertices listed to one part, and the remainder to the other part.
\end{itemize}

\subsection{Waterdance Options}
\begin{tabular}{|l|l|} \hline
Name & \texttt{numDances} \\ \hline
Type & \texttt{Int} \\ \hline
Default & \texttt{1} \\ \hline
\end{tabular}\\
                      
At each level of graph refinement, both the Fiduccia-Mattheyses refinement algorithm and the quadratic programming algorithm are used to refine the graph. This combination of algorithms, run back-to-back, is informally referred to as a waterdance. \texttt{numDances} is used to specify the number of waterdances.\\
\\
For example, if \texttt{numDances = 2}, at each refinement level, the FM refinement will be done, then QP refinement, then FM and QP again.

\subsection{Fiduccia-Mattheyes Options}

\begin{tabular}{|l|l|} \hline
Name & \texttt{useFM} \\ \hline
Type & \texttt{bool} \\ \hline
Default & \texttt{true} \\ \hline
\end{tabular}\\

\texttt{useFM} can be used to enable or disable the use of the Fiduccia-Mattheyses refinement algorithm. If \texttt{useFM} is \texttt{false}, then the FM refinement is skipped.\\

\begin{tabular}{|l|l|} \hline
Name & \texttt{fmSearchDepth} \\ \hline
Type & \texttt{Int} \\ \hline
Default & \texttt{50} \\ \hline
\end{tabular}\\

The Fiduccia-Mattheyses algorithm attempts to make positive gain moves whenever possible. However, to better explore the non-convex search space, the FM algorithm will make unfavorable moves in an attempt to locate another more favorable solution. The \texttt{fmSearchDepth} limits the number of these unfavorable moves before the algorithm stops.

\vskip 1\baselineskip
\begin{tabular}{|l|l|} \hline
Name & \texttt{fmConsiderCount} \\ \hline
Type & \texttt{Int} \\ \hline
Default & \texttt{3} \\ \hline
\end{tabular}\\

During the Fiduccia-Mattheyses algorithm, a heap is maintained of the vertices sorted by their gains. Vertices that have fewer neighbors in the same part relative to neighbors in the opposite part are prioritized higher in the heap (with higher gains), and are generally more likely to yield better quality cuts when swapped to the opposite part. \texttt{fmConsiderCount} defines the number of vertices at the top of the heap to consider swapping to the opposite part before terminating. When a vertex swap being considered does not yield a better cut after moving \texttt{fmSearchDepth} vertices, that iteration terminates, and the next vertex in the heap is considered.

\vskip 1\baselineskip
\begin{tabular}{|l|l|} \hline
Name & \texttt{fmMaxNumRefinements} \\ \hline
Type & \texttt{Int} \\ \hline
Default & \texttt{20} \\ \hline
\end{tabular}\\

\texttt{fmMaxNumRefinements} specifies the number of passes the Fiduccia-Mattheyses algorithm takes over the graph. During each pass, suboptimal moves may be attempted to escape local optima.

\subsection{Quadratic Programming Options}

\begin{tabular}{|l|l|} \hline
Name & \texttt{useQPGradProj} \\ \hline
Type & \texttt{bool} \\ \hline
Default & \texttt{true} \\ \hline
\end{tabular}\\

\texttt{useQPGradProj} can be used to enable or disable the use of the quadratic programming refinement algorithm. If \texttt{useQPGradProj} is \texttt{false}, then the QP refinement is skipped. This may provide faster solutions at the cost of cut quality.\\
\vskip 1\baselineskip
\begin{tabular}{|l|l|} \hline
Name & \texttt{gradProjTolerance} \\ \hline
Type & \texttt{double} \\ \hline
Default & \texttt{0.001} \\ \hline
\end{tabular}\\

Convergence tolerance for the projected gradient algorithm in the quadratic programming refinement approach.  Decreasing the tolerance may improve solution quality at the cost of additional computation time. It may also be advisable to increase \texttt{gradprojIterationLimit}, as a decreased tolerance may require additional iterations to converge.\\
\vskip 1\baselineskip
\begin{tabular}{|l|l|} \hline
Name & \texttt{gradprojIterationLimit} \\ \hline
Type & \texttt{Int} \\ \hline
Default & \texttt{50} \\ \hline
\end{tabular}\\

Maximum number of iterations for the gradient projection algorithm in the quadratic programming refinement approach. More iterations may allow the gradient projection algorithm to find a better solution at the cost of additional computation time.

\subsection{Final Partition Target Options}

\begin{tabular}{|l|l|} \hline
Name & \texttt{targetSplit} \\ \hline
Type & \texttt{double} \\ \hline
Default & \texttt{0.5} \\ \hline
\end{tabular}\\

\texttt{targetSplit} specifies the desired balance of the edge cut. The default is a balanced cut (0.5). Note that the target split takes into account weighted vertices.\\
\vskip 1\baselineskip
\begin{tabular}{|l|l|} \hline
Name & \texttt{softSplitTolerance} \\ \hline
Type & \texttt{double} \\ \hline
Default & \texttt{0} \\ \hline
\end{tabular}\\

Cuts within \texttt{targetSplit} $\pm$ \texttt{softSplitTolerance} are treated equally. For example, if any cut within 0.4 and 0.6 balance is acceptable, the user may specify \texttt{targetSplit} = 0.5 and \texttt{softSplitTolerance} = 0.1.\\

\subsection{Other Options}

\begin{tabular}{|l|l|} \hline
Name & \texttt{randomSeed} \\ \hline
Type & \texttt{Int} \\ \hline
Default & \texttt{0} \\ \hline
\end{tabular}\\

Random number generation is used primarily in random matching strategies (\texttt{matchingStrategy = Random}) and random initial guesses (\texttt{guessCutType = GuessRandom}). \texttt{randomSeed} can be used to seed the random number generator with a specific value.

\section{References}

\bibliographystyle{acm}
\bibliography{references}


\printindex

\end{document}  