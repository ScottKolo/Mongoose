\hypertarget{mongoose__cs_8cpp}{}\section{/\+Users/scott/\+Documents/\+Research/\+Mongoose/\+Source/mongoose\+\_\+cs.cpp File Reference}
\label{mongoose__cs_8cpp}\index{/\+Users/scott/\+Documents/\+Research/\+Mongoose/\+Source/mongoose\+\_\+cs.\+cpp@{/\+Users/scott/\+Documents/\+Research/\+Mongoose/\+Source/mongoose\+\_\+cs.\+cpp}}


Subset of C\+Sparse library for sparse matrix handling.  


{\ttfamily \#include \char`\"{}mongoose\+\_\+internal.\+hpp\char`\"{}}\\*
{\ttfamily \#include \char`\"{}mongoose\+\_\+cs.\+hpp\char`\"{}}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
csi $\ast$ {\bfseries Mongoose\+::cs\+\_\+counts} (const cs $\ast$A, const csi $\ast$parent, const csi $\ast$post, csi ata)\hypertarget{mongoose__cs_8cpp_acb29e4bf4084eda121225ece4ce31cf6}{}\label{mongoose__cs_8cpp_acb29e4bf4084eda121225ece4ce31cf6}

\item 
double {\bfseries Mongoose\+::cs\+\_\+cumsum} (csi $\ast$p, csi $\ast$c, csi n)\hypertarget{mongoose__cs_8cpp_a23d4d5e0800aad2fc913da64ab134905}{}\label{mongoose__cs_8cpp_a23d4d5e0800aad2fc913da64ab134905}

\item 
csi {\bfseries Mongoose\+::cs\+\_\+scatter} (const cs $\ast$A, csi j, double beta, csi $\ast$w, double $\ast$x, csi mark, cs $\ast$C, csi nz)\hypertarget{mongoose__cs_8cpp_ad49815602060d8a608d27023c146d576}{}\label{mongoose__cs_8cpp_ad49815602060d8a608d27023c146d576}

\item 
csi {\bfseries Mongoose\+::cs\+\_\+sprealloc} (cs $\ast$A, csi nzmax)\hypertarget{mongoose__cs_8cpp_ae481bc1af8affa90b40d463ea4b3b395}{}\label{mongoose__cs_8cpp_ae481bc1af8affa90b40d463ea4b3b395}

\item 
cs $\ast$ {\bfseries Mongoose\+::cs\+\_\+done} (cs $\ast$C, void $\ast$w, void $\ast$x, csi ok)\hypertarget{mongoose__cs_8cpp_a0ec8f329559f55565f8dd8f7f34e0d47}{}\label{mongoose__cs_8cpp_a0ec8f329559f55565f8dd8f7f34e0d47}

\item 
csd $\ast$ {\bfseries Mongoose\+::cs\+\_\+dalloc} (csi m, csi n)\hypertarget{mongoose__cs_8cpp_a717587c618e588fbffe0ac282ee8a580}{}\label{mongoose__cs_8cpp_a717587c618e588fbffe0ac282ee8a580}

\item 
cs $\ast$ {\bfseries Mongoose\+::cs\+\_\+spfree} (cs $\ast$A)\hypertarget{mongoose__cs_8cpp_a091935bb14f70e4ca2875ea35617d9b3}{}\label{mongoose__cs_8cpp_a091935bb14f70e4ca2875ea35617d9b3}

\item 
csd $\ast$ {\bfseries Mongoose\+::cs\+\_\+ddone} (csd $\ast$D, cs $\ast$C, void $\ast$w, csi ok)\hypertarget{mongoose__cs_8cpp_a8dd64763b1b9de06458fc6ade81ea55e}{}\label{mongoose__cs_8cpp_a8dd64763b1b9de06458fc6ade81ea55e}

\item 
csi {\bfseries Mongoose\+::cs\+\_\+dfs} (csi j, cs $\ast$G, csi top, csi $\ast$xi, csi $\ast$pstack, const csi $\ast$pinv)\hypertarget{mongoose__cs_8cpp_a7e2c227f9682c652f423a5a17f4f5d0f}{}\label{mongoose__cs_8cpp_a7e2c227f9682c652f423a5a17f4f5d0f}

\item 
cs $\ast$ \hyperlink{mongoose__cs_8cpp_afd7b4530c280c91c43ae695c8d515a42}{Mongoose\+::cs\+\_\+transpose} (const cs $\ast$A, csi values)
\begin{DoxyCompactList}\small\item\em C = A\textquotesingle{}. \end{DoxyCompactList}\item 
cs $\ast$ \hyperlink{mongoose__cs_8cpp_a2153d61eda5ac1e1b70617e8cf8cde33}{Mongoose\+::cs\+\_\+add} (const cs $\ast$A, const cs $\ast$B, double alpha, double beta)
\begin{DoxyCompactList}\small\item\em C = alpha$\ast$A + beta$\ast$B. \end{DoxyCompactList}\item 
cs $\ast$ {\bfseries Mongoose\+::cs\+\_\+compress} (const cs $\ast$T)\hypertarget{mongoose__cs_8cpp_a867fb9806212fa756422dd9b01cad293}{}\label{mongoose__cs_8cpp_a867fb9806212fa756422dd9b01cad293}

\item 
cs $\ast$ {\bfseries Mongoose\+::cs\+\_\+spalloc} (csi m, csi n, csi nzmax, csi values, csi triplet)\hypertarget{mongoose__cs_8cpp_a0fa999ba128bf47a2d3e850902632ee0}{}\label{mongoose__cs_8cpp_a0fa999ba128bf47a2d3e850902632ee0}

\item 
csd $\ast$ {\bfseries Mongoose\+::cs\+\_\+dfree} (csd $\ast$D)\hypertarget{mongoose__cs_8cpp_af890f3acd5e9c91d56db604c9588ac75}{}\label{mongoose__cs_8cpp_af890f3acd5e9c91d56db604c9588ac75}

\item 
csd $\ast$ {\bfseries Mongoose\+::cs\+\_\+scc} (cs $\ast$A)\hypertarget{mongoose__cs_8cpp_ae7a5086f0e92053c57ee14e6983a6864}{}\label{mongoose__cs_8cpp_ae7a5086f0e92053c57ee14e6983a6864}

\item 
cs $\ast$ {\bfseries Mongoose\+::cs\+\_\+submat} (const cs $\ast$A, const csi i1, const csi i2, const csi j1, const csi j2)\hypertarget{mongoose__cs_8cpp_af1b3fa2cdde0640c61538248856248f1}{}\label{mongoose__cs_8cpp_af1b3fa2cdde0640c61538248856248f1}

\item 
cs $\ast$ {\bfseries Mongoose\+::cs\+\_\+permute} (const cs $\ast$A, const csi $\ast$pinv, const csi $\ast$q, csi values)\hypertarget{mongoose__cs_8cpp_af26cb6523bce1312c41c05aa81682451}{}\label{mongoose__cs_8cpp_af26cb6523bce1312c41c05aa81682451}

\item 
csi $\ast$ {\bfseries Mongoose\+::cs\+\_\+pinv} (csi const $\ast$p, csi n)\hypertarget{mongoose__cs_8cpp_acf53ac9514abcb8d1775ee586bd5c331}{}\label{mongoose__cs_8cpp_acf53ac9514abcb8d1775ee586bd5c331}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Subset of C\+Sparse library for sparse matrix handling. 

\begin{DoxyAuthor}{Author}
Timothy Davis, Nuri Yeralan, Scott Kolodziej 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
23 Aug 2015 Graphs are often represented by sparse adjacency matrices. As such, a number of sparse matrix operations are performed by Mongoose. 
\end{DoxyDate}


\subsection{Function Documentation}
\index{mongoose\+\_\+cs.\+cpp@{mongoose\+\_\+cs.\+cpp}!cs\+\_\+add@{cs\+\_\+add}}
\index{cs\+\_\+add@{cs\+\_\+add}!mongoose\+\_\+cs.\+cpp@{mongoose\+\_\+cs.\+cpp}}
\subsubsection[{\texorpdfstring{cs\+\_\+add(const cs $\ast$\+A, const cs $\ast$\+B, double alpha, double beta)}{cs_add(const cs *A, const cs *B, double alpha, double beta)}}]{\setlength{\rightskip}{0pt plus 5cm}cs $\ast$ Mongoose\+::cs\+\_\+add (
\begin{DoxyParamCaption}
\item[{const {\bf cs} $\ast$}]{A, }
\item[{const {\bf cs} $\ast$}]{B, }
\item[{double}]{alpha, }
\item[{double}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{mongoose__cs_8cpp_file_a2153d61eda5ac1e1b70617e8cf8cde33}{}\label{mongoose__cs_8cpp_file_a2153d61eda5ac1e1b70617e8cf8cde33}


C = alpha$\ast$A + beta$\ast$B. 

Given two C\+Sparse matrices {\ttfamily A} and {\ttfamily B}, and scaling constants {\ttfamily alpha} and {\ttfamily beta}, cs\+\_\+add returns a new matrix such that C = alpha$\ast$A + beta$\ast$B. In other words, C(i,j) = alpha$\ast$A(i,j) + beta$\ast$B(i,j).


\begin{DoxyCode}
cs *C = \hyperlink{mongoose__cs_8cpp_a2153d61eda5ac1e1b70617e8cf8cde33}{cs\_add}(A, B, 1, 1);     \textcolor{comment}{// C = A + B}
cs *D = \hyperlink{mongoose__cs_8cpp_a2153d61eda5ac1e1b70617e8cf8cde33}{cs\_add}(A, B, 0.5, 0.5); \textcolor{comment}{// C = 0.5*A + 0.5*B}
cs *E = \hyperlink{mongoose__cs_8cpp_a2153d61eda5ac1e1b70617e8cf8cde33}{cs\_add}(A, B, 1, 0);     \textcolor{comment}{// C = A}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em A} & Matrix to be added to B. \\
\hline
{\em B} & Matrix to be added to A \\
\hline
{\em alpha} & Scalar (double) value to scale all elements of A matrix by \\
\hline
{\em beta} & Scalar (double) value to scale all elements of B matrix by \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A matrix such that C = alpha$\ast$A + beta$\ast$B 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Allocates memory for the returned matrix, but frees on error. 
\end{DoxyNote}
\index{mongoose\+\_\+cs.\+cpp@{mongoose\+\_\+cs.\+cpp}!cs\+\_\+transpose@{cs\+\_\+transpose}}
\index{cs\+\_\+transpose@{cs\+\_\+transpose}!mongoose\+\_\+cs.\+cpp@{mongoose\+\_\+cs.\+cpp}}
\subsubsection[{\texorpdfstring{cs\+\_\+transpose(const cs $\ast$\+A, csi values)}{cs_transpose(const cs *A, csi values)}}]{\setlength{\rightskip}{0pt plus 5cm}cs $\ast$ Mongoose\+::cs\+\_\+transpose (
\begin{DoxyParamCaption}
\item[{const {\bf cs} $\ast$}]{A, }
\item[{csi}]{values}
\end{DoxyParamCaption}
)}\hypertarget{mongoose__cs_8cpp_file_afd7b4530c280c91c43ae695c8d515a42}{}\label{mongoose__cs_8cpp_file_afd7b4530c280c91c43ae695c8d515a42}


C = A\textquotesingle{}. 

Given a C\+Sparse matrix {\ttfamily A}, cs\+\_\+transpose returns a new matrix that is the transpose of {\ttfamily A}. In other words, C(j,i) = A(i,j). The second parameter, {\ttfamily values}, allows for the copying of the A-\/$>$x array. If {\ttfamily values} = 0, the A-\/$>$x array is ignored, and C-\/$>$x is left N\+U\+LL. If {\ttfamily values} != 0, then the A-\/$>$x array is copied (transposed) to C-\/$>$x.


\begin{DoxyCode}
cs *C = \hyperlink{mongoose__cs_8cpp_afd7b4530c280c91c43ae695c8d515a42}{cs\_transpose}(A, 0); \textcolor{comment}{// C is A' but C->x = NULL}
cs *D = \hyperlink{mongoose__cs_8cpp_afd7b4530c280c91c43ae695c8d515a42}{cs\_transpose}(A, 1); \textcolor{comment}{// D is A' and C->x is transpose of A->x}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em A} & Matrix to be transposed \\
\hline
{\em values} & 1 to transpose the values A-\/$>$x, 0 to ignore \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A transposed version of A 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Allocates memory for the returned matrix, but frees on error. 
\end{DoxyNote}
