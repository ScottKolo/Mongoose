<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mongoose: /Users/scott/Documents/Research/Mongoose/Source/Mongoose_CSparse.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mongoose
   </div>
   <div id="projectbrief">A Graph Partitioning Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_74389ed8173ad57b461b9d623a1f3867.html">Source</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mongoose_CSparse.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Fundamental sparse matrix operations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;Mongoose_Internal.hpp&quot;</code><br />
<code>#include &quot;Mongoose_CSparse.hpp&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acb29e4bf4084eda121225ece4ce31cf6"><td class="memItemLeft" align="right" valign="top"><a id="acb29e4bf4084eda121225ece4ce31cf6"></a>
csi *&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_counts</b> (const cs *A, const csi *parent, const csi *post, csi ata)</td></tr>
<tr class="separator:acb29e4bf4084eda121225ece4ce31cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d4d5e0800aad2fc913da64ab134905"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_mongoose___c_sparse_8cpp.html#a23d4d5e0800aad2fc913da64ab134905">Mongoose::cs_cumsum</a> (csi *p, csi *c, csi n)</td></tr>
<tr class="memdesc:a23d4d5e0800aad2fc913da64ab134905"><td class="mdescLeft">&#160;</td><td class="mdescRight">p [0..n] = cumulative sum of c [0..n-1], and then copy p [0..n-1] into c  <a href="_mongoose___c_sparse_8cpp.html#a23d4d5e0800aad2fc913da64ab134905">More...</a><br /></td></tr>
<tr class="separator:a23d4d5e0800aad2fc913da64ab134905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49815602060d8a608d27023c146d576"><td class="memItemLeft" align="right" valign="top"><a id="ad49815602060d8a608d27023c146d576"></a>
csi&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_scatter</b> (const cs *A, csi j, double beta, csi *w, double *x, csi mark, cs *C, csi nz)</td></tr>
<tr class="separator:ad49815602060d8a608d27023c146d576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae481bc1af8affa90b40d463ea4b3b395"><td class="memItemLeft" align="right" valign="top">csi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_mongoose___c_sparse_8cpp.html#ae481bc1af8affa90b40d463ea4b3b395">Mongoose::cs_sprealloc</a> (cs *A, csi nzmax)</td></tr>
<tr class="memdesc:ae481bc1af8affa90b40d463ea4b3b395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the max number of entries in a sparse matrix.  <a href="_mongoose___c_sparse_8cpp.html#ae481bc1af8affa90b40d463ea4b3b395">More...</a><br /></td></tr>
<tr class="separator:ae481bc1af8affa90b40d463ea4b3b395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec8f329559f55565f8dd8f7f34e0d47"><td class="memItemLeft" align="right" valign="top"><a id="a0ec8f329559f55565f8dd8f7f34e0d47"></a>
cs *&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_done</b> (cs *C, void *w, void *x, csi ok)</td></tr>
<tr class="separator:a0ec8f329559f55565f8dd8f7f34e0d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717587c618e588fbffe0ac282ee8a580"><td class="memItemLeft" align="right" valign="top"><a id="a717587c618e588fbffe0ac282ee8a580"></a>
csd *&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_dalloc</b> (csi m, csi n)</td></tr>
<tr class="separator:a717587c618e588fbffe0ac282ee8a580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091935bb14f70e4ca2875ea35617d9b3"><td class="memItemLeft" align="right" valign="top"><a id="a091935bb14f70e4ca2875ea35617d9b3"></a>
cs *&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_spfree</b> (cs *A)</td></tr>
<tr class="separator:a091935bb14f70e4ca2875ea35617d9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd64763b1b9de06458fc6ade81ea55e"><td class="memItemLeft" align="right" valign="top"><a id="a8dd64763b1b9de06458fc6ade81ea55e"></a>
csd *&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_ddone</b> (csd *D, cs *C, void *w, csi ok)</td></tr>
<tr class="separator:a8dd64763b1b9de06458fc6ade81ea55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2c227f9682c652f423a5a17f4f5d0f"><td class="memItemLeft" align="right" valign="top"><a id="a7e2c227f9682c652f423a5a17f4f5d0f"></a>
csi&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_dfs</b> (csi j, cs *G, csi top, csi *xi, csi *pstack, const csi *pinv)</td></tr>
<tr class="separator:a7e2c227f9682c652f423a5a17f4f5d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7b4530c280c91c43ae695c8d515a42"><td class="memItemLeft" align="right" valign="top">cs *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_mongoose___c_sparse_8cpp.html#afd7b4530c280c91c43ae695c8d515a42">Mongoose::cs_transpose</a> (const cs *A, csi values)</td></tr>
<tr class="memdesc:afd7b4530c280c91c43ae695c8d515a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">C = A'.  <a href="_mongoose___c_sparse_8cpp.html#afd7b4530c280c91c43ae695c8d515a42">More...</a><br /></td></tr>
<tr class="separator:afd7b4530c280c91c43ae695c8d515a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2153d61eda5ac1e1b70617e8cf8cde33"><td class="memItemLeft" align="right" valign="top">cs *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_mongoose___c_sparse_8cpp.html#a2153d61eda5ac1e1b70617e8cf8cde33">Mongoose::cs_add</a> (const cs *A, const cs *B, double alpha, double beta)</td></tr>
<tr class="memdesc:a2153d61eda5ac1e1b70617e8cf8cde33"><td class="mdescLeft">&#160;</td><td class="mdescRight">C = alpha*A + beta*B.  <a href="_mongoose___c_sparse_8cpp.html#a2153d61eda5ac1e1b70617e8cf8cde33">More...</a><br /></td></tr>
<tr class="separator:a2153d61eda5ac1e1b70617e8cf8cde33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867fb9806212fa756422dd9b01cad293"><td class="memItemLeft" align="right" valign="top">cs *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_mongoose___c_sparse_8cpp.html#a867fb9806212fa756422dd9b01cad293">Mongoose::cs_compress</a> (const cs *T)</td></tr>
<tr class="memdesc:a867fb9806212fa756422dd9b01cad293"><td class="mdescLeft">&#160;</td><td class="mdescRight">C = compressed-column form of a triplet matrix T.  <a href="_mongoose___c_sparse_8cpp.html#a867fb9806212fa756422dd9b01cad293">More...</a><br /></td></tr>
<tr class="separator:a867fb9806212fa756422dd9b01cad293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa999ba128bf47a2d3e850902632ee0"><td class="memItemLeft" align="right" valign="top"><a id="a0fa999ba128bf47a2d3e850902632ee0"></a>
cs *&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_spalloc</b> (csi m, csi n, csi nzmax, csi values, csi triplet)</td></tr>
<tr class="separator:a0fa999ba128bf47a2d3e850902632ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af890f3acd5e9c91d56db604c9588ac75"><td class="memItemLeft" align="right" valign="top"><a id="af890f3acd5e9c91d56db604c9588ac75"></a>
csd *&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_dfree</b> (csd *D)</td></tr>
<tr class="separator:af890f3acd5e9c91d56db604c9588ac75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a5086f0e92053c57ee14e6983a6864"><td class="memItemLeft" align="right" valign="top"><a id="ae7a5086f0e92053c57ee14e6983a6864"></a>
csd *&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_scc</b> (cs *A)</td></tr>
<tr class="separator:ae7a5086f0e92053c57ee14e6983a6864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b3fa2cdde0640c61538248856248f1"><td class="memItemLeft" align="right" valign="top"><a id="af1b3fa2cdde0640c61538248856248f1"></a>
cs *&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_submat</b> (const cs *A, const csi i1, const csi i2, const csi j1, const csi j2)</td></tr>
<tr class="separator:af1b3fa2cdde0640c61538248856248f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26cb6523bce1312c41c05aa81682451"><td class="memItemLeft" align="right" valign="top"><a id="af26cb6523bce1312c41c05aa81682451"></a>
cs *&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_permute</b> (const cs *A, const csi *pinv, const csi *q, csi values)</td></tr>
<tr class="separator:af26cb6523bce1312c41c05aa81682451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf53ac9514abcb8d1775ee586bd5c331"><td class="memItemLeft" align="right" valign="top"><a id="acf53ac9514abcb8d1775ee586bd5c331"></a>
csi *&#160;</td><td class="memItemRight" valign="bottom"><b>Mongoose::cs_pinv</b> (csi const *p, csi n)</td></tr>
<tr class="separator:acf53ac9514abcb8d1775ee586bd5c331"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Fundamental sparse matrix operations. </p>
<dl class="section author"><dt>Author</dt><dd>Timothy Davis, Nuri Yeralan, Scott Kolodziej</dd></dl>
<p>A subset of the CSparse library is used for its sparse matrix data structure and efficient fundamental matrix operations, such as adding, permuting, and finding strongly connected components.</p>
<dl class="section author"><dt>Author</dt><dd>Tim Davis, Nuri Yeralan, Scott Kolodziej</dd></dl>
<p>A subset of the CSparse library is used for its sparse matrix data structure and efficient fundamental matrix operations, such as adding, permuting, and finding strongly connected components. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="file_a2153d61eda5ac1e1b70617e8cf8cde33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a2153d61eda5ac1e1b70617e8cf8cde33">&sect;&nbsp;</a></span>cs_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs * Mongoose::cs_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_mongoose_1_1cs__sparse.html">cs</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mongoose_1_1cs__sparse.html">cs</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C = alpha*A + beta*B. </p>
<p>Given two CSparse matrices <code>A</code> and <code>B</code>, and scaling constants <code>alpha</code> and <code>beta</code>, cs_add returns a new matrix such that C = alpha*A + beta*B. In other words, C(i,j) = alpha*A(i,j) + beta*B(i,j).</p>
<div class="fragment"><div class="line">cs *C = <a class="code" href="_mongoose___c_sparse_8cpp.html#a2153d61eda5ac1e1b70617e8cf8cde33">cs_add</a>(A, B, 1, 1);     <span class="comment">// C = A + B</span></div><div class="line">cs *D = <a class="code" href="_mongoose___c_sparse_8cpp.html#a2153d61eda5ac1e1b70617e8cf8cde33">cs_add</a>(A, B, 0.5, 0.5); <span class="comment">// C = 0.5*A + 0.5*B</span></div><div class="line">cs *E = <a class="code" href="_mongoose___c_sparse_8cpp.html#a2153d61eda5ac1e1b70617e8cf8cde33">cs_add</a>(A, B, 1, 0);     <span class="comment">// C = A</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix to be added to B. </td></tr>
    <tr><td class="paramname">B</td><td>Matrix to be added to A </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar (double) value to scale all elements of A matrix by </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar (double) value to scale all elements of B matrix by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix such that C = alpha*A + beta*B </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Allocates memory for the returned matrix, but frees on error. </dd></dl>

</div>
</div>
<a id="file_a867fb9806212fa756422dd9b01cad293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a867fb9806212fa756422dd9b01cad293">&sect;&nbsp;</a></span>cs_compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs * Mongoose::cs_compress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_mongoose_1_1cs__sparse.html">cs</a> *&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C = compressed-column form of a triplet matrix T. </p>
<p>Given a CSparse matrix <code>T</code> in triplet form, cs_compress returns the same matrix in compressed sparse column (CSC) format.</p>
<p>A triplet form matrix is a simple listing of the nonzeros in the matrix and their row, column coordinates. For example, the 2x2 identity matrix would be specified with the following triplets in (row, column, value) format: (1, 1, 1) and (2, 2, 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Matrix in triplet form to be compressed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A compressed sparse column (CSC) format matrix representing the triplet form matrix T passed in. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses an O(n) workspace w, and frees on error. </dd></dl>

</div>
</div>
<a id="file_a23d4d5e0800aad2fc913da64ab134905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a23d4d5e0800aad2fc913da64ab134905">&sect;&nbsp;</a></span>cs_cumsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Mongoose::cs_cumsum </td>
          <td>(</td>
          <td class="paramtype">csi *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">csi *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">csi&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>p [0..n] = cumulative sum of c [0..n-1], and then copy p [0..n-1] into c </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A vector of size <code>n</code> to be summed. On return, p is overwritten such that p[i] contains the cumulative sum of p[0..i] that was passed in. </td></tr>
    <tr><td class="paramname">c</td><td>A vector of size <code>n</code> used as a workspace. On return, c[i] contains the cumulative sum of p[0..i]. </td></tr>
    <tr><td class="paramname">n</td><td>The dimension of <code>p</code> and <code>c</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cumulative sum of c[0..n-1] </dd></dl>

</div>
</div>
<a id="file_ae481bc1af8affa90b40d463ea4b3b395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ae481bc1af8affa90b40d463ea4b3b395">&sect;&nbsp;</a></span>cs_sprealloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">csi Mongoose::cs_sprealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mongoose_1_1cs__sparse.html">cs</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">csi&#160;</td>
          <td class="paramname"><em>nzmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the max number of entries in a sparse matrix. </p>
<p>Given a CSparse matrix <code>A</code> in compressed sparse column format, cs_sprealloc (i.e. Sparse Matrix Reallocation) will modify the matrix data structure to allow for a new maximum capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The sparse matrix (in compressed sparse column format) to be reallocated. </td></tr>
    <tr><td class="paramname">nzmax</td><td>The new maximum number of nonzeros the matrix should be able to accomodate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code ok valued 1 for success and 0 for failure. </dd></dl>

</div>
</div>
<a id="file_afd7b4530c280c91c43ae695c8d515a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_afd7b4530c280c91c43ae695c8d515a42">&sect;&nbsp;</a></span>cs_transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs * Mongoose::cs_transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_mongoose_1_1cs__sparse.html">cs</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">csi&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C = A'. </p>
<p>Given a CSparse matrix <code>A</code>, cs_transpose returns a new matrix that is the transpose of <code>A</code>. In other words, C(j,i) = A(i,j). The second parameter, <code>values</code>, allows for the copying of the A-&gt;x array. If <code>values</code> = 0, the A-&gt;x array is ignored, and C-&gt;x is left NULL. If <code>values</code> != 0, then the A-&gt;x array is copied (transposed) to C-&gt;x.</p>
<div class="fragment"><div class="line">cs *C = <a class="code" href="_mongoose___c_sparse_8cpp.html#afd7b4530c280c91c43ae695c8d515a42">cs_transpose</a>(A, 0); <span class="comment">// C is A&#39; but C-&gt;x = NULL</span></div><div class="line">cs *D = <a class="code" href="_mongoose___c_sparse_8cpp.html#afd7b4530c280c91c43ae695c8d515a42">cs_transpose</a>(A, 1); <span class="comment">// D is A&#39; and C-&gt;x is transpose of A-&gt;x</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix to be transposed </td></tr>
    <tr><td class="paramname">values</td><td>1 to transpose the values A-&gt;x, 0 to ignore </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A transposed version of A </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Allocates memory for the returned matrix, but frees on error. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
