#!/usr/bin/env python
from __future__ import absolute_import, print_function, unicode_literals
from subprocess import call, check_output
import os       # For filesystem access
import sys      # For sys.exit()
import argparse # For parsing command-line arguments
import urllib   # For downloading the UFget index
import tarfile  # For un-tar/unzipping matrix files
import csv      # For reading the UFget index
import shutil   # For using 'which'
from distutils.spawn import find_executable # For using find_executable
import json

def main():
    # Check to make sure we're in the build directory - if not, exit
    checkLocation()

    # Parse the command-line arguments
    args = parseArguments()

    # Run tests
    runTests(args)

def runTests(args):
    # Create or locate matrix temporary storage directory
    matrix_dir = getMatrixDirectory(args)

    # Download the matrix stats csv file
    stats_file = downloadStatsFile(matrix_dir)
    
    # Use a dictionary to store the mean times for each matrix 
    meanTime = {}

    with open(stats_file, 'rb') as f:
        reader = csv.reader(f)

        # Matrix IDs are not listed in the stats file - we just have to keep count
        matrix_id = 0
        for row in reader:

            if len(row) == 12: # Only rows with 12 elements represent matrix data
                matrix_id += 1

                # Check if the matrix ID is in the proper range and 
                # that the matrix is real and symmetric
                isInBounds = ((matrix_id >= args.id_min) and (matrix_id <= args.id_max))
                isSquare = (row[2] == row[3])
                isReal = (row[5] == '1')

                if (isInBounds and isSquare and isReal):
                    if args.ids is None or matrix_id in args.ids:
                        matrix_name = row[0] + '/' + row[1] + '.tar.gz'
                        gzip_path = matrix_dir + row[0] + '_' + row[1] + '.tar.gz'
                        matrix_path = matrix_dir + row[1] + '/' + row[1] + ".mtx"
                        
                        matrix_exists = os.path.isfile(gzip_path)
                        if matrix_exists:
                            tar = tarfile.open(gzip_path, mode='r:gz')
                            matrix_files = tar.getnames()
                        else:
                            # Download matrix if it doesn't exist
                            print("Downloading " + matrix_name)
                            testfile = urllib.URLopener()
                            testfile.retrieve("https://www.cise.ufl.edu/research/sparse/MM/" + matrix_name, gzip_path)
                            tar = tarfile.open(gzip_path, mode='r:gz')
                            tar.extractall(path=matrix_dir) # Extract the matrix from the tar.gz file
                            tar.close()

                        times = {"Total": [], 
                                 "Matching": [], 
                                 "Coarsening": [], 
                                 "Refinement": [], 
                                 "FM": [], 
                                 "QP": [], 
                                 "IO": []}
                        meanTime[matrix_id] = {}
                        for i in range(0, args.n):
                            outputFile = row[0] + '_' + row[1] + '_performance.txt'
                            call(["./tests/mongoose_test_performance", matrix_path, outputFile])
                            with open(outputFile, 'rb') as f:
                                runData = json.load(f)
                                times["Total"].append(runData["Timing"]["Total"])
                                times["Matching"].append(runData["Timing"]["Matching"])
                                times["Coarsening"].append(runData["Timing"]["Coarsening"])
                                times["Refinement"].append(runData["Timing"]["Refinement"])
                                times["FM"].append(runData["Timing"]["FM"])
                                times["QP"].append(runData["Timing"]["QP"])
                                times["IO"].append(runData["Timing"]["IO"])

                        meanTime[matrix_id]["Name"] = row[1]
                        meanTime[matrix_id]["Group"] = row[0]
                        meanTime[matrix_id]["Total"] = trimmedMean(times["Total"], args.trimmed_percentage)
                        meanTime[matrix_id]["Matching"] = trimmedMean(times["Matching"], args.trimmed_percentage)
                        meanTime[matrix_id]["Coarsening"] = trimmedMean(times["Coarsening"], args.trimmed_percentage)
                        meanTime[matrix_id]["Refinement"] = trimmedMean(times["Refinement"], args.trimmed_percentage)
                        meanTime[matrix_id]["FM"] = trimmedMean(times["FM"], args.trimmed_percentage)
                        meanTime[matrix_id]["QP"] = trimmedMean(times["QP"], args.trimmed_percentage)
                        meanTime[matrix_id]["IO"] = trimmedMean(times["IO"], args.trimmed_percentage)

                        # Delete the matrix only if we downloaded it and the keep
                        # flag is off
                        if args.purge or not (args.keep or matrix_exists):
                            files = os.listdir(matrix_dir + row[1])
                            for file in files:
                                os.remove(os.path.join(matrix_dir + row[1] + '/', file))
                            os.rmdir(matrix_dir + row[1])
                            os.remove(gzip_path)

    # Delete the UFstats.csv file now that we're done
    os.remove(stats_file)

    # Print the statistics to stdout
    printStats(meanTime)
    
    # If an output file was provided, write the statistics to file as JSON
    if args.output_file:
        with open(args.output_file, 'w') as f:
            f.write(json.dumps(meanTime, indent=4))

def printStats(meanTime):
    for id, times in meanTime.items():
        print("Matrix ID: " + str(id) + ", " + times["Group"] + "/" + times["Name"])
        print("  Total Time:   %.6fs" % times["Total"])
        print("    Matching:   %.6fs" % times["Matching"])
        print("    Coarsening: %.6fs" % times["Coarsening"])
        print("    Refinement: %.6fs" % times["Refinement"])
        print("    FM:         %.6fs" % times["FM"])
        print("    QP:         %.6fs" % times["QP"])
        print("    IO:         %.6fs" % times["IO"])
        print()

def trimmedMean(times, percentage):
    trimmedTimes = trim(times, percentage)
    trimmedMean = mean(trimmedTimes)
    return trimmedMean

def trim(times, percentage):
    numToTrim = int(round(len(times) * percentage/100))
    for i in range(0, numToTrim):
        times.remove(min(times))
        times.remove(max(times))
    return times

def mean(times):
    return sum(times)/len(times)

def getMatrixDirectory(args):
    # Check if the supplied matrix download directory exists - if not, create it
    matrix_dir = args.matrix_directory
    if not os.path.exists(matrix_dir):
        os.makedirs(matrix_dir)

    # Make sure the directory ends with '/'
    if not matrix_dir.endswith('/'):
        matrix_dir = matrix_dir + '/'

    return matrix_dir

def downloadStatsFile(matrix_dir):
    downloader = urllib.URLopener()
    downloader.retrieve(
        "https://www.cise.ufl.edu/research/sparse/matrices/UFstats.csv", 
        matrix_dir + "/UFstats.csv")

    stats_file = matrix_dir + "/UFstats.csv"
    return stats_file

def parseArguments():
    parser = argparse.ArgumentParser(
                        description='Calculate performance statistics for the Mongoose library.')
    parser.add_argument('-k', '--keep', 
                        action='store_true', 
                        help='do not remove downloaded files when test is complete')
    parser.add_argument('-p', '--purge', 
                        action='store_true', 
                        help='force remove downloaded matrix files when complete')
    parser.add_argument('-min', 
                        action='store', 
                        metavar='min_id', 
                        type=int, 
                        default=1,
                        dest='id_min',
                        help='minimum matrix ID to run tests on [default: 1]')
    parser.add_argument('-max', 
                        action='store', 
                        metavar='max_id', 
                        type=int, 
                        default=2757,
                        dest='id_max',
                        help='maximum matrix ID to run tests on [default: 2757]')
    parser.add_argument('-i', '--ids', 
                        action='store', 
                        nargs='+', 
                        metavar='matrix_ID', 
                        type=int,
                        help='list of matrix IDs to run tests on')
    parser.add_argument('-d', '--matrix-directory', 
                        action='store', 
                        metavar='matrix_dir',
                        default='../Matrix',
                        help='download directory for Matrix Market data files')
    parser.add_argument('-n', 
                        action='store', 
                        type=int, 
                        default=5,
                        help='number of trials to run per matrix [default: 5]')
    parser.add_argument('-t', '--trimmed-percentage',
                        action='store', 
                        type=int, 
                        default=20,
                        help='Percent by which the mean is trimmed [default: 20]')
    parser.add_argument('-o', '--output-file',
                        action='store',
                        default='',
                        help='output performance statistics in JSON to the given file')

    return parser.parse_args()

def checkLocation():
    # Check if we are in the right location - if not, exit
    if not (os.path.isdir('./CMakeFiles/mongoose_dbg.dir/Source')
            and os.path.isdir('../Source')):
        print(
            "\n\033[91mERROR!\033[0m Looks like you might not be running this from "
            "your build directory.\n\n"
            "Make sure that... \n\n"
            "  * You are in your build directory (e.g. Mongoose/_build) and\n"
            "  * You have built Mongoose ('cmake ..' followed by 'make')\n")
        sys.exit()

    # Check if Mongoose has been built - if not, exit
    if not (os.path.exists('./CMakeFiles/mongoose_dbg.dir/Source/Mongoose_Graph.o')):
        print(
            "\n\033[91mERROR!\033[0m Looks like you might not have built Mongoose "
            "yet.\n\n"
            "Make sure that... \n\n"
            "  * You are in your build directory (e.g. Mongoose/_build) and\n"
            "  * You have built Mongoose ('cmake ..' followed by 'make')\n")
        sys.exit()

if __name__=="__main__":
   main()